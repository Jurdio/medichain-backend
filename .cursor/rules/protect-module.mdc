---
alwaysApply: false
---
## Правила для ProtectModule (сертифікати)

### Огляд
- **Призначення:** Видача сертифікатів (мінт NFT) та збереження історії транзакцій.
- **Маршрут модуля:** `@Controller('protect')`
- **Ключова логіка отримувача NFT:**
  - Якщо в запиті є `manualWallet` — мінтимо на нього (має бути Solana-адреса).
  - Якщо `manualWallet` немає — шукаємо Solana-гаманець користувача через Privy за `patientEmail`.
  - Якщо Solana-гаманець не знайдено — повертаємо `404 Wallet not found by email`.
  - Метадата NFT не містить PII, вкладень або email.

### Ендпоінти
- `POST /protect/create-certificate`
  - Формат: `multipart/form-data`
  - Поля:
    - `attachments` — файл (binary), опційно; зберігається локально в `./uploads` з унікальним ім’ям (`diskStorage`, `uuid` + розширення).
    - Тіло (DTO `CreateCertificateDto`):
      - `doctorWalletAddress` (string, required)
      - `patientEmail` (email, required)
      - `manualWallet` (string, optional; Solana-адреса, якщо передано)
      - `certificateType` (string, optional)
      - `title` (string, optional)
      - `description` (string, optional)
      - `issueDate` (date string, optional)
  - Відповідь: `{ message, nftAddress, transactionSignature, data, file }`

### Потік виконання (service)
1. Формуємо мінімальну JSON-метадату (без файлів, email, title/description):
   - `name: 'MediCert'`
   - `symbol: 'MEDICERT'`
   - `seller_fee_basis_points: 0` (роялті вимкнені)
   - `attributes`: `certificate_type` (з DTO), `issue_date` (ISO, якщо є), `network` (з `NftService.getNetwork()`), `version: '1.0'`
   Завантажуємо JSON через `NftService.uploadJsonMetadata` (Irys → Arweave) та отримуємо `metadataUrl`.
   Примітка: відповідь API не блокується очікуванням доступності gateway; у фоні запускається діагностичний пробінг URI по кількох gateway.
2. Визначаємо отримувача:
   - Якщо `manualWallet` присутній — використовуємо його.
   - Інакше виконуємо пошук через `PrivyService.getPrimaryWalletByEmail(patientEmail)`; якщо не знайдено — `NotFoundException('Wallet not found by email')`.
3. Мінтимо NFT: `NftService.mintNft(resolvedWallet, metadataUrl, 'MediCert', 0)`.
4. Зберігаємо історію: `HistoryService.create({...})` з `doctorWalletAddress`, `patientWalletAddress=resolvedWallet`, `nftMintAddress`, `transactionSignature`.
5. Повертаємо `{ message, nftAddress, transactionSignature, data, file }` (де `file` — `file?.originalname`, якщо був аплоуд; у метадату файл не включається).

### Валідація та документація
- DTO `CreateCertificateDto` з `class-validator`/`class-transformer` та `@nestjs/swagger` (`@ApiProperty`).
  - `manualWallet` — `@IsOptional() @IsString()`; `@ApiProperty({ required: false })`.
- Файл обробляється через `@UseInterceptors(FileInterceptor('attachments', diskStorage(...)))`, зберігається локально в `./uploads`; наразі у метадату NFT не включається.

### Нотатки з безпеки та зберігання
- У прод середовищі: зберігати файли у S3/IPFS/Arweave; не тримати у локальній ФС.
- Валідація типів файлів і розміру повинна бути додана перед продом.

### Мережа та інтеграції
- Мінтинг виконується у мережі, налаштованій через `SOLANA_RPC_URL` (за замовчуванням devnet).
- Приймаємо лише Solana-адреси (для `manualWallet` і адрес з Privy).
- Адреса отримувача має мати достатньо SOL для rent-exempt мінту асоційованого акаунта токена.
- Для інтеграції з Privy необхідні змінні оточення: `PRIVY_APP_ID`, `PRIVY_APP_SECRET`.
- Логи (`Nest Logger`) фіксують кроки пошуку гаманця у Privy (форма відповіді, кількість користувачів, нормалізовані гаманці, вибір Solana-адреси).
 - Зберігання метадати: через Irys (ex-Bundlr) → Arweave (`irysStorage` у Metaplex). URI може стати доступним на різних gateway неодночасно: `https://devnet.irys.xyz/<txid>` часто швидше, ніж `https://arweave.net/<txid>`. Ми не чекаємо доступності у відповіді API; у фоні ведеться діагностичний пробінг.

### Метадата NFT (мінімальна схема)
- Публічні поля on-chain: `name`, `symbol` (необов’язково ончейн), `uri`, `sellerFeeBasisPoints=0`, `creators`/`updateAuthority` — від технічного гаманця.
- Off-chain JSON за `uri` включає:
  - `name: 'MediCert'`, `symbol: 'MEDICERT'`, `seller_fee_basis_points: 0`
  - `attributes`: `certificate_type`, `issue_date?`, `network`, `version: '1.0'`
  - Без email/PII/вкладень.

### Приклади запитів
```bash
curl -X POST 'http://localhost:3000/protect/create-certificate' \
  -H 'Accept: application/json' \
  -F 'doctorWalletAddress=6vdaANCiHoDVSidCWddiAwHqGDKUZDCuVHeJ1AqD9NMq' \
  -F 'patientEmail=patient@example.com' \
  -F 'title=Health Certificate' \
  -F 'attachments=@/path/to/file.pdf'
```

Альтернатива з ручною адресою:
```bash
curl -X POST 'http://localhost:3000/protect/create-certificate' \
  -H 'Accept: application/json' \
  -F 'doctorWalletAddress=6vdaANCiHoDVSidCWddiAwHqGDKUZDCuVHeJ1AqD9NMq' \
  -F 'patientEmail=patient@example.com' \
  -F 'manualWallet=CJkiCzp8qAxkPaNyvPuR6HGZmcSimcLBbkoVsJeEXEMq' \
  -F 'title=Health Certificate' \
  -F 'attachments=@/path/to/file.pdf'
```

### Обробка помилок та типові проблеми
- `404 Wallet not found by email` — у Privy не знайдено Solana-гаманця для `patientEmail` і `manualWallet` не передано.
- `"Unexpected field"` — назва поля файлу в запиті не збігається з `FileInterceptor('attachments', ...)`.
- `Attempt to debit an account but found no record of a prior credit` — у гаманця отримувача недостатньо SOL для rent-exempt.
- `Name too long` — назва NFT перевищує 32 символи; в `ProtectService` назва скорочується.
- Off-chain `uri` тимчасово недоступний на окремих gateway (Arweave/Irys) — це очікувано; UI має показувати стан “pending metadata” та/або використовувати кілька gateway з фолбеком.

