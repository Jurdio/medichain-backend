Rule Name: backend-verify-module
Description: 
### Правила та рекомендації для роботи з модулем верифікації (`VerifyModule`)

Цей документ описує архітектуру, поточну реалізацію та майбутні напрямки покращення модуля верифікації NFT-сертифікатів MediCert.

#### 1. Призначення модуля

Модуль `VerifyModule` відповідає за одну ключову задачу: за хешем транзакції Solana (`txHash`) визначити, чи був у цій транзакції створений або оновлений валідний NFT-сертифікат, що належить MediCert.

**Ключовий критерій валідності (на даному етапі):** `updateAuthority` в метаданих NFT має збігатися з офіційною публічною адресою MediCert, що зберігається в змінній оточення `MEDICERT_UPDATE_AUTHORITY`.

#### 2. Поточний робочий процес (Workflow)

1.  **API Endpoint**: `POST /verify/transaction` приймає JSON з єдиним полем `txHash`.
2.  **Сервіс (`VerifyService`)**:
    *   Отримує транзакцію з блокчейну за допомогою `connection.getParsedTransaction()`.
    *   Викликає внутрішній метод `extractMintCandidatesFromTx()` для пошуку потенційних NFT-адрес.
    *   **Ітеративно перевіряє кожного кандидата** за допомогою `verifyMint()`, який використовує Metaplex SDK (`metaplex.nfts().findByMint()`).
    *   Агрегує результати та повертає статус (`FOUND`, `NOT_FOUND`, `AMBIGUOUS`).

#### 3. Відома проблема та ключове обмеження: "Шумний" пошук кандидатів

**Основна проблема поточної реалізації** — це метод `extractMintCandidatesFromTx()`.

*   **Як він працює зараз:** Метод сканує всі інструкції транзакції. Якщо інструкція звертається до головної програми метаданих Metaplex (`Token Metadata Program`), він наївно додає **абсолютно всі** акаунти (адреси), що згадані в цій інструкції, до списку кандидатів на перевірку.
*   **Наслідки:** У список кандидатів потрапляють не лише реальні NFT, а й гаманці користувачів, системні програми, службові акаунти тощо. Це призводить до того, що поле `details.candidates` у відповіді API перетворюється на довгий, "брудний" список, де більшість записів — це відхилені кандидати з помилкою `"Not a valid Metaplex NFT"`.

**ВАЖЛИВО:** Спроба вирішити цю проблему шляхом створення статичного списку відомих системних адрес для їх фільтрації була **відхилена як погане рішення**. Такий підхід ненадійний і вимагає постійного оновлення.

#### 4. Рекомендації для майбутніх покращень (Ключовий пріоритет)

Майбутні зміни в цьому модулі мають бути зосереджені на **підвищенні точності** методу `extractMintCandidatesFromTx()`.

**Мета:** Метод має ідентифікувати **лише ті адреси, які є безпосередньо NFT mint-ами**, а не всі дотичні акаунти.

**Рекомендований підхід — аналіз структури інструкцій:**

Замість того, щоб просто реагувати на `programId`, потрібно аналізувати конкретний тип інструкції, що викликається, та її структуру.

1.  **Точна ідентифікація:**
    *   Для інструкції створення метаданих (`createMetadataAccountV3`), mint-адреса завжди є **другим акаунтом** в списку. Найкращий спосіб її отримати — через розпарсені дані: `inst.parsed.info.mint`.
    *   Для інших інструкцій (наприклад, `updateMetadataAccountV2`, `mintNewEditionFromMasterEditionViaToken`) mint-адреса також знаходиться на **чітко визначеній позиції**.
2.  **Завдання для AI-агента:**
    *   **Дослідити:** Використовуючи документацію Metaplex або аналізатори блокчейну (наприклад, Solscan), визначити точні позиції (індекси) mint-акаунтів для найпоширеніших інструкцій програми Token Metadata.
    *   **Реалізувати:** Оновити `extractMintCandidatesFromTx()`, додавши логіку, яка перевіряє тип інструкції та витягує адресу **лише з потрібного місця**, ігноруючи решту акаунтів.

**Чого слід уникати:**
*   Не повертайтеся до ідеї "чорного списку" (фільтрації за хардкодним списком).
*   Рішення має бути побудоване на **позитивній ідентифікації** (ми точно знаємо, де шукати mint), а не на негативній фільтрації.

**Кінцевий результат:** Після правильної реалізації, у відповіді API поле `details.candidates` має містити лише 1-2 записи, які є реальними кандидатами на звання NFT-сертифіката, що зробить відповідь чистою, точною і зрозумілою.